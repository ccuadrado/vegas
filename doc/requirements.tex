\section{Requirements Analysis}

\subsection{Static Requirements}

In the following sections we will outline the project requirements. Each
requirement will have a short name, which is indicative of purpose for the
feature and is intended to for identifying the requirement. In addition, there
is a short user story, which explains the functionality in further detail.
Finally, each requirement will have a section which describes the acceptance
test which must pass for the requirement to be accepted.

The section on testing bares further discussion of terminology and notation.
Because the goal of the project is to make a file system for a POSIX
environment, it seems only right to define the desired operation in terms of
standard *NIX command line tool. Although for the project we will be creating an
automated test suite for all specified tests, it should also be possible to
verify correct operation using only tools on the command line.

As such, we will make heavy use of the following tools:

\begin{figure}[H]
\centering
\begin{tabular}{|c|c|}
\hline
COMMAND & DESCRIPTION \\\hline

ls -1 & Output each file in the directory on per line.\\

cat \textit{filename} & Output the contents of \textit{filename} to standard
output.\\

cut -d \textit{sep} -f \textit{field} & Output only the field numbered
\textit{field} using \textit{sep} to separate columns.\\

grep -i \textit{regex} & Output lines from the input that match \textit{regex}.
Case insensitive.\\

wc -l & Read the input and output the number of lines.\\\hline
\end{tabular}
\end{figure}

We assume familiarity with regular expressions and with UNIX
pipes\footnote{TODO: Add references for refreshers}. In user stories, any path
component prefixed with a ':' is to be considered a wildcard, and will be
referenced by the name following the symbol.

\hrulefill

\newcounter{requirements}
\newenvironment{Requirements}
  {\begin{list}{SR-\arabic{requirements}.}%
               {\usecounter{requirements}}}%
  {\end{list}}

\begin{Requirements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item Get information for a user.

\textbf{User Story:} A user reads the file to the path \texttt{/:user/info.txt}.
Inside the file they see information regarding the user named \texttt{:user}. It
contains the following attributes:

\begin{itemize}
\item Full name
\item Screen name
\item Followers count
\item Statuses count
\item Location
\item Join date
\end{itemize}

\textbf{How to test:} The following should ouput "Lou Scoras".

\begin{alltt}
    \$ cat /ljsc/info.txt | grep -i 'Full-Name' | cut -d: -f2 
\end{alltt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item Get a tweet given a particular id\label{req:get-a-tweet}

\textbf{User Story:} A user reads the file \texttt{/tweets/:tweet\_id.txt}.
The contents of the file will have the body of the tweet, which will contain:

\begin{itemize}
\item Message
\item Date
\item Author
\end{itemize}

If the user wants only the message contents, they can read the contents of
\texttt{/tweets/:tweet\_id/body.txt} alone.

\textbf{How to test:} Using the following command on predetermined tweet
\textit{n} yields ``This is a canned tweet.``

\begin{alltt}
    \$ cat /tweets/n/body.txt
\end{alltt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item Get a user's latest tweets\label{req:get-latest}

\textbf{User Story:} A user lists the contents of the directory
\texttt{/:user/tweets/latest}. For each tweet in the timeline there will be a
file in the directory, \texttt{:tweet\_id.txt}. The contents of this file are as
described in SR-\ref{req:get-a-tweet}.

\textbf{How to test:} Take any tweet in a user's timeline within the last $n$
tweets, all of which are considered the latest. Let this tweets id be
\textit{tweet\_id}. The following command should then output $1$.

\begin{alltt}
    \$ ls -1 /vegasfs/tweets/latest | grep -i "\textit{tweet\_id}.txt" | wc -l
\end{alltt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item Get a user's @mentions

\textbf{User Story:} This directory returns a user's mentions, up to 800 tweets (A
limitation by the API). To access the latest mentions, the user can list the
contents of \texttt{/:user/mentions} for the latest mentions for that user.
Also, they can fetch \texttt{/:user/mentions/:j-:k/} to list all the mentions
between the $j$th and $k$th mention in the timeline. Each file in these
directories will be \texttt{:tweet\_id.txt} and have the information as in
SR-\ref{req:get-a-tweet}.

\textbf{How to test:} For each file in the directory of mentions, we can ensure
that they all begin with `@` and contain \texttt{@:username}. The following
three commands should output the same value:

\begin{alltt}
    \$ cat /\textit{:user}/mentions/*.txt | wc -l
    \$ cat /\textit{:user}/mentions/*.txt | grep '^message:@' | wc -l
    \$ cat /\textit{:user}/mentions/*.txt | grep '^message:@' | grep '@\textit{:username}' | wc -l
\end{alltt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item Create a new tweet

\textbf{User Story:} This feature allows creation of a new tweet by writing to a
file at location \texttt{/tweets/new.txt} with the contents of your tweet. The
date and author information will be appended automatically by the twitter
system.

\textbf{How to test:} Create a new tweet.

\begin{alltt}
    \$ vi /tweets/new.txt  # edit and save
\end{alltt}

The following command should contain the message entered in the previous step.

\begin{alltt}
    \$ cat \texttt{/:user/tweets/latest/}\$(ls -lt1 \texttt{/:user/tweets/latest} | head -n 1)
\end{alltt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item Search for a hashtag
\item Search for tweets in a geographical area

\item View tweets with images as images
\item Open a link for a given tweet as the expanded web page

\end{Requirements}

\subsection{Optional Requirements}
